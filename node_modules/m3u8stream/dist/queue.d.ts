<<<<<<< Updated upstream
declare type Callback = (err?: Error, result?: any) => void;
interface Task {
    item: {};
    callback: Callback;
}
export default class Queue {
    _worker: (item: any, cb: Callback) => void;
    _concurrency: number;
    tasks: Task[];
=======
export declare type Callback = (err: Error | null, result?: any) => void;
interface Task<T> {
    item: T;
    callback?: Callback;
}
declare type Worker<T> = (item: T, cb: Callback) => void;
export declare class Queue<T = unknown> {
    private _worker;
    private _concurrency;
    tasks: Task<T>[];
>>>>>>> Stashed changes
    total: number;
    active: number;
    /**
     * A really simple queue with concurrency.
<<<<<<< Updated upstream
     */
    constructor(worker: (item: any, cb: Callback) => void, options?: {
=======
     *
     * @param {Function} worker
     * @param {Object} options
     * @param {!number} options.concurrency
     */
    constructor(worker: Worker<T>, options?: {
>>>>>>> Stashed changes
        concurrency?: number;
    });
    /**
     * Push a task to the queue.
<<<<<<< Updated upstream
     */
    push(item: any, callback?: Callback): void;
=======
     *
     *  @param {T} item
     *  @param {!Function} callback
     */
    push(item: T, callback?: Callback): void;
>>>>>>> Stashed changes
    /**
     * Process next job in queue.
     */
    _next(): void;
    /**
     * Stops processing queued jobs.
     */
    die(): void;
}
export {};
